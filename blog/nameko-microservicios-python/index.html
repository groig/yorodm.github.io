    <!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="author" content="Yoandy Rodríguez Martínez">
        <meta name="description" content="Software, la vida y todo lo demás">
        <meta name="generator" content="Hugo 0.49-DEV" />
        <title>Desarrollando microservicios con Nameko &middot; /home/yorodm</title>
        <link rel="shortcut icon" href="https://yorodm.github.io/images/favicon.ico">
        <link rel="stylesheet" href="https://yorodm.github.io/css/style.css">
        <link rel="stylesheet" href="https://yorodm.github.io/css/syntax.css">
        

        
        <link rel="stylesheet" href="https://yorodm.github.io/css/font-awesome.min.css">
        

        
        <link href="https://yorodm.github.io/index.xml" rel="alternate" type="application/rss+xml" title="/home/yorodm" />
        
    </head>

    <body>
       <nav class="main-nav">
    
    
        <a href='https://yorodm.github.io/'> <span class="arrow">←</span>inicio</a>
    
    <a href='https://yorodm.github.io/blog'>archivo</a>
    <a href='https://yorodm.github.io/tags'>etiquetas</a>
    <a href='https://yorodm.github.io/about'>acerca de</a>

    

    
        <a class="symbol" href="https://yorodm.github.io/index.xml"><i class="fa fa-rss"></i> </a>
    
</nav>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Desarrollando microservicios con Nameko
                    </h1>
                    <h2 class="headline">
                        9 de Nov 2017
                    · 559 palabras 
                    · 3 minutos apróx. 
                      <span class="tags">
                      
                      
                          
                              <a href="https://yorodm.github.io/tags/nameko">nameko</a>
                          
                              <a href="https://yorodm.github.io/tags/python">python</a>
                          
                              <a href="https://yorodm.github.io/tags/microservicios">microservicios</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                    <section id="post-body">
                        

<h1 id="desarrollando-microservicios-con-nameko">Desarrollando microservicios con Nameko</h1>

<p><a href="http://github.com/nameko/nameko">Nameko</a> es una biblioteca para el desarrollo
de microservicios en <strong>Python</strong>. A diferencia de otros <strong>frameworks</strong> como
<a href="https://www.djangoproject.com">Django</a>, <a href="http://flask.pocoo.org">Flask</a> y
<a href="http://www.hug.rest">Hug</a> que tienen como principal objetivo utilizar <strong>HTTP</strong>
para la comunicación con los clientes, <strong>Nameko</strong> viene con soporte integrado
para <strong>AMQP</strong> y <strong>Websockets</strong> y nos permite adicionar nuestros propios
protocolos.</p>

<h2 id="manos-a-la-obra">Manos a la obra.</h2>

<p>Para hacer servicios con <strong>Nameko</strong> necesitamos algunas cosas:</p>

<ol>
<li><strong>Python 2</strong> (creo que no hay versiones para <strong>Python 3</strong>).</li>
<li>Un entorno virtual (<code>virtualenv</code>).</li>
<li>La biblioteca (vía <code>pip</code> para garantizar las dependencias).</li>
<li><strong>RabbitMQ</strong> u otro servidor de mensajería que soporte <strong>AMQP</strong>.</li>
<li><strong>Emacs</strong> (o tu editor favorito).</li>
</ol>

<p>Creemos dos servicios:</p>

<ol>
<li>Servicio que hace una operación intensiva (sumar dos números) al que llamamos
<code>Calculate</code></li>
<li>Servicio que nos notifica cuando <code>Calculate</code> termina, al que llamamos <code>Notify</code>.</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">nameko.rpc</span> <span class="kn">import</span> <span class="n">rpc</span><span class="p">,</span> <span class="n">RpcProxy</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">class</span> <span class="nc">Compute</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span><span class="s2">&#34;compute&#34;</span>
    <span class="n">notify</span> <span class="o">=</span> <span class="n">RpcProxy</span><span class="p">(</span><span class="s2">&#34;notify&#34;</span><span class="p">)</span>

    <span class="nd">@rpc</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="o">.</span><span class="n">send</span><span class="o">.</span><span class="n">call_async</span><span class="p">(</span><span class="s2">&#34;Operation completed </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>


<span class="k">class</span> <span class="nc">Notify</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span><span class="s2">&#34;notify&#34;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="nd">@rpc</span>
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></code></pre></div>
<p>Salvemos el archivo como <code>services.py</code> y ya estamos listos para ejecutar los servicios</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ nameko run --broker pyamqp://guest:guest@localhost services</code></pre></div>
<p>Si accedemos a la consola web de <strong>RabbitMQ</strong> podemos ver las colas de mensaje
creadas para los servicios. Eso confirma que se están funcionando correctamente.</p>


<figure>
    
        <img src="/images/nameko-microservicios/rabbit-queues.png" />
    
    
</figure>


<h2 id="accediendo-a-los-servicios">Accediendo a los servicios.</h2>

<p>Antes de desplegar nuestros servicios en producción, probemos que funcionan
correctamente. Desafortunadamente fuimos demasiado rápido y no creamos pruebas
unitarias (muy mal de nuestra parte) así que necesitamos alguna forma de
verificar que las interfaces hagan lo planeado (este concepto de suma es
aparentemente muy complicado).</p>

<p>Por suerte <strong>Nameko</strong> nos proporciona un <strong>REPL</strong> mediante el comando <code>shell</code>
que nos permite interactuar con los servicios desde código <strong>Python</strong>.</p>
<div class="highlight"><pre class="chroma"><code class="language-terminal" data-lang="terminal">nameko shell --broker  pyamqp://guest:guest@192.168.184.142
Nameko Python 2.7.13 [MSC v.1500 64 bit (AMD64)] shell
Broker: pyamqp://guest:guest@192.168.184.142
&gt;&gt;&gt; n.rpc.compute.method(99999,99999)
199998
    &gt;&gt;&gt; reply=n.rpc.compute.method.call_async(99999,99999)
&gt;&gt;&gt; reply.result()
199998
&gt;&gt;&gt;</code></pre></div>
<p>Perfecto, funcionan tanto las llamadas síncronas como las asíncronas, con esto en mano
podemos utilizar los servicios desde, por ejemplo, un modelo en <strong>Odoo</strong>.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">nameko.standalone.rpc</span> <span class="kn">import</span> <span class="n">ClusterRpcProxy</span>
<span class="n">BROKER</span> <span class="o">=</span><span class="s1">&#39;pyamqp://guest:guest@192.168.184.142&#39;</span>

<span class="c1"># Todas las cosas del modelo....</span>
    <span class="nd">@api.multi</span>
    <span class="k">def</span> <span class="nf">action_suma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">campo_1</span>
        <span class="n">val2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">campo_2</span>
        <span class="k">with</span> <span class="n">ClusterRpcProxy</span><span class="p">(</span><span class="n">BROKER</span><span class="p">)</span> <span class="k">as</span> <span class="n">rpc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val3</span> <span class="o">=</span> <span class="n">rpc</span><span class="o">.</span><span class="n">compute</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span><span class="n">val2</span><span class="p">)</span></code></pre></div>
<p>Gracias a que <strong>RabbitMQ</strong> actúa como <em>broker</em> y registro de los servicios,
podemos desplegar tantos como queramos, el consumidor no necesita saber donde
están localizados, ni cuantos son, como un plus, los servicios se pueden añadir
dinámicamente a al <em>cluster</em></p>

<h2 id="adicionando-un-hearbeat">Adicionando un hearbeat.</h2>

<p>Nuestros servicios funcionan, es hora de desplegarlos en producción, pero el
sysadmin se queja de que no tiene forma de monitorear el estado de los mismos.
Aunque estamos absolutamente seguros de que nuestros servicios tienen un 100% de
disponibilidad, para complacerlos adicionamos un <strong>hearbeat</strong> que se ejecute
cada un tiempo configurable en cada una de las instancias.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">nameko.timer</span> <span class="kn">import</span> <span class="n">timer</span>
<span class="c1"># Método ficticio que envía un mensaje a la plataforma</span>
<span class="c1"># de monitoreo.</span>
<span class="kn">from</span> <span class="nn">monitoring</span> <span class="kn">import</span> <span class="n">ping</span>

<span class="k">class</span> <span class="nc">Heartbear</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&#34;heartbeat&#34;</span>

    <span class="nd">@timer</span>
    <span class="k">def</span> <span class="nf">beat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ping</span><span class="p">()</span></code></pre></div>
<h2 id="más-de-nameko">Más de Nameko.</h2>

<p>Además de <strong>RPC</strong> vía <strong>AMQP</strong>, <strong>Nameko</strong> proporciona facilidades para crear
<strong>Web APIs</strong>, notificación de eventos entre servicios, integración con
<strong>Django</strong>, <strong>Flask</strong>, <strong>SQLAlchemy</strong> y permite crear nuestros propios puntos de
entrada para servicio (ya hemos visto <code>@rpc y @timer</code>). En lo particular lo
considero una alternativa interesante y rápida que necesita pocas dependencias
tanto para desarrollo como para despliegue. Si estás interesado puedes consultar
la <a href="http://nameko.readthedocs.io/en/stable/">documentación oficial</a>.</p>

                    </section>
            </article>

            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "home-yorodm" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="http://github.com/yorodm">
        <i class="fa fa-github"></i>
    </a>
    
    <a class="symbol" href="http://stackoverflow.com/yorodm">
        <i class="fa fa-stack-overflow"></i>
    </a>
    
    <a class="symbol" href="http://twitter.com/yorodm">
        <i class="fa fa-twitter"></i>
    </a>
    


</div>

    
    <p class="small">
        
        © Copyright 2019 Yoandy Rodríguez Martínez
        
    </p>

    <p class="small">
        Powered by  <a href="http://www.gnu.org/software/emacs">GNU Emacs</a> <i class="fa fa-heart" aria-hidden="true"></i> and <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://yorodm.github.io/js/jquery-2.2.4.min.js"></script>
<script src="https://yorodm.github.io/js/main.js"></script>







    </body>
</html>
